import{T as t}from"./splaytree.BjOK7GKI.js";const e=134217729;function n(t,e,n,i,s){let r,o,l,h,u=e[0],c=i[0],g=0,p=0;c>u==c>-u?(r=u,u=e[++g]):(r=c,c=i[++p]);let f=0;if(g<t&&p<n)for(c>u==c>-u?(o=u+r,l=r-(o-u),u=e[++g]):(o=c+r,l=r-(o-c),c=i[++p]),r=o,0!==l&&(s[f++]=l);g<t&&p<n;)c>u==c>-u?(o=r+u,h=o-r,l=r-(o-h)+(u-h),u=e[++g]):(o=r+c,h=o-r,l=r-(o-h)+(c-h),c=i[++p]),r=o,0!==l&&(s[f++]=l);for(;g<t;)o=r+u,h=o-r,l=r-(o-h)+(u-h),u=e[++g],r=o,0!==l&&(s[f++]=l);for(;p<n;)o=r+c,h=o-r,l=r-(o-h)+(c-h),c=i[++p],r=o,0!==l&&(s[f++]=l);return 0===r&&0!==f||(s[f++]=r),f}function i(t){return new Float64Array(t)}const s=i(4),r=i(8),o=i(12),l=i(16),h=i(4);function u(t,i,u,c,g,p){const f=(i-p)*(u-g),y=(t-g)*(c-p),x=f-y,a=Math.abs(f+y);return Math.abs(x)>=33306690738754716e-32*a?x:-function(t,i,u,c,g,p,f){let y,x,a,b,E,m,S,d,v,w,R,I,_,P,k,A,O,L;const N=t-g,$=u-g,M=i-p,B=c-p;P=N*B,m=e*N,S=m-(m-N),d=N-S,m=e*B,v=m-(m-B),w=B-v,k=d*w-(P-S*v-d*v-S*w),A=M*$,m=e*M,S=m-(m-M),d=M-S,m=e*$,v=m-(m-$),w=$-v,O=d*w-(A-S*v-d*v-S*w),R=k-O,E=k-R,s[0]=k-(R+E)+(E-O),I=P+R,E=I-P,_=P-(I-E)+(R-E),R=_-A,E=_-R,s[1]=_-(R+E)+(E-A),L=I+R,E=L-I,s[2]=I-(L-E)+(R-E),s[3]=L;let G=function(t,e){let n=e[0];for(let i=1;i<t;i++)n+=e[i];return n}(4,s),T=22204460492503146e-32*f;if(G>=T||-G>=T)return G;if(E=t-N,y=t-(N+E)+(E-g),E=u-$,a=u-($+E)+(E-g),E=i-M,x=i-(M+E)+(E-p),E=c-B,b=c-(B+E)+(E-p),0===y&&0===x&&0===a&&0===b)return G;if(T=11093356479670487e-47*f+33306690738754706e-32*Math.abs(G),G+=N*b+B*y-(M*a+$*x),G>=T||-G>=T)return G;P=y*B,m=e*y,S=m-(m-y),d=y-S,m=e*B,v=m-(m-B),w=B-v,k=d*w-(P-S*v-d*v-S*w),A=x*$,m=e*x,S=m-(m-x),d=x-S,m=e*$,v=m-(m-$),w=$-v,O=d*w-(A-S*v-d*v-S*w),R=k-O,E=k-R,h[0]=k-(R+E)+(E-O),I=P+R,E=I-P,_=P-(I-E)+(R-E),R=_-A,E=_-R,h[1]=_-(R+E)+(E-A),L=I+R,E=L-I,h[2]=I-(L-E)+(R-E),h[3]=L;const q=n(4,s,4,h,r);P=N*b,m=e*N,S=m-(m-N),d=N-S,m=e*b,v=m-(m-b),w=b-v,k=d*w-(P-S*v-d*v-S*w),A=M*a,m=e*M,S=m-(m-M),d=M-S,m=e*a,v=m-(m-a),w=a-v,O=d*w-(A-S*v-d*v-S*w),R=k-O,E=k-R,h[0]=k-(R+E)+(E-O),I=P+R,E=I-P,_=P-(I-E)+(R-E),R=_-A,E=_-R,h[1]=_-(R+E)+(E-A),L=I+R,E=L-I,h[2]=I-(L-E)+(R-E),h[3]=L;const F=n(q,r,4,h,o);P=y*b,m=e*y,S=m-(m-y),d=y-S,m=e*b,v=m-(m-b),w=b-v,k=d*w-(P-S*v-d*v-S*w),A=x*a,m=e*x,S=m-(m-x),d=x-S,m=e*a,v=m-(m-a),w=a-v,O=d*w-(A-S*v-d*v-S*w),R=k-O,E=k-R,h[0]=k-(R+E)+(E-O),I=P+R,E=I-P,_=P-(I-E)+(R-E),R=_-A,E=_-R,h[1]=_-(R+E)+(E-A),L=I+R,E=L-I,h[2]=I-(L-E)+(R-E),h[3]=L;const z=n(F,o,4,h,l);return l[z-1]}(t,i,u,c,g,p,a)}var c={};const g=(t,e)=>t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y,p=(t,e)=>{if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;const n=t.ll.x<e.ll.x?e.ll.x:t.ll.x,i=t.ur.x<e.ur.x?t.ur.x:e.ur.x;return{ll:{x:n,y:t.ll.y<e.ll.y?e.ll.y:t.ll.y},ur:{x:i,y:t.ur.y<e.ur.y?t.ur.y:e.ur.y}}};let f=Number.EPSILON;void 0===f&&(f=Math.pow(2,-52));const y=f*f,x=(t,e)=>{if(-f<t&&t<f&&-f<e&&e<f)return 0;const n=t-e;return n*n<y*t*e?0:t<e?-1:1};class a{constructor(){this.tree=new t,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(null!==n&&0===x(e.key,n.key))return this.tree.remove(t),n.key;const i=this.tree.next(e);return null!==i&&0===x(e.key,i.key)?(this.tree.remove(t),i.key):t}}const b=new class{constructor(){this.reset()}reset(){this.xRounder=new a,this.yRounder=new a}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}},E=(t,e)=>t.x*e.y-t.y*e.x,m=(t,e)=>t.x*e.x+t.y*e.y,S=(t,e,n)=>{const i=u(t.x,t.y,e.x,e.y,n.x,n.y);return i>0?-1:i<0?1:0},d=t=>Math.sqrt(m(t,t)),v=(t,e,n)=>{const i={x:e.x-t.x,y:e.y-t.y},s={x:n.x-t.x,y:n.y-t.y};return E(s,i)/d(s)/d(i)},w=(t,e,n)=>{const i={x:e.x-t.x,y:e.y-t.y},s={x:n.x-t.x,y:n.y-t.y};return m(s,i)/d(s)/d(i)},R=(t,e,n)=>0===e.y?null:{x:t.x+e.x/e.y*(n-t.y),y:n},I=(t,e,n)=>0===e.x?null:{x:n,y:t.y+e.y/e.x*(n-t.x)};class _{static compare(t,e){const n=_.comparePoints(t.point,e.point);return 0!==n?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:k.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){void 0===t.events?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let n=0,i=e.length;n<i;n++){const t=e[n];this.point.events.push(t),t.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(void 0===n.segment.consumedBy)for(let i=e+1;i<t;i++){const t=this.point.events[i];void 0===t.consumedBy&&(n.otherSE.point.events===t.otherSE.point.events&&n.segment.consume(t.segment))}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const n=this.point.events[e];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&t.push(n)}return t}getLeftmostComparator(t){const e=new Map,n=n=>{const i=n.otherSE;e.set(n,{sine:v(this.point,t.point,i.point),cosine:w(this.point,t.point,i.point)})};return(t,i)=>{e.has(t)||n(t),e.has(i)||n(i);const{sine:s,cosine:r}=e.get(t),{sine:o,cosine:l}=e.get(i);return s>=0&&o>=0?r<l?1:r>l?-1:0:s<0&&o<0?r<l?-1:r>l?1:0:o<s?-1:o>s?1:0}}}let P=0;class k{static compare(t,e){const n=t.leftSE.point.x,i=e.leftSE.point.x,s=t.rightSE.point.x,r=e.rightSE.point.x;if(r<n)return 1;if(s<i)return-1;const o=t.leftSE.point.y,l=e.leftSE.point.y,h=t.rightSE.point.y,u=e.rightSE.point.y;if(n<i){if(l<o&&l<h)return 1;if(l>o&&l>h)return-1;const n=t.comparePoint(e.leftSE.point);if(n<0)return 1;if(n>0)return-1;const i=e.comparePoint(t.rightSE.point);return 0!==i?i:-1}if(n>i){if(o<l&&o<u)return-1;if(o>l&&o>u)return 1;const n=e.comparePoint(t.leftSE.point);if(0!==n)return n;const i=t.comparePoint(e.rightSE.point);return i<0?1:i>0?-1:1}if(o<l)return-1;if(o>l)return 1;if(s<r){const n=e.comparePoint(t.rightSE.point);if(0!==n)return n}if(s>r){const n=t.comparePoint(e.rightSE.point);if(n<0)return 1;if(n>0)return-1}if(s!==r){const t=h-o,e=s-n,c=u-l,g=r-i;if(t>e&&c<g)return 1;if(t<e&&c>g)return-1}return s>r?1:s<r||h<u?-1:h>u?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,i){this.id=++P,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=i}static fromRing(t,e,n){let i,s,r;const o=_.comparePoints(t,e);if(o<0)i=t,s=e,r=1;else{if(!(o>0))throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);i=e,s=t,r=-1}const l=new _(i,!0),h=new _(s,!1);return new k(l,h,[n],[r])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,i=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const s=(t.y-e.y)/i.y,r=e.x+s*i.x;if(t.x===r)return 0;const o=(t.x-e.x)/i.x,l=e.y+o*i.y;return t.y===l?0:t.y<l?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),i=p(e,n);if(null===i)return null;const s=this.leftSE.point,r=this.rightSE.point,o=t.leftSE.point,l=t.rightSE.point,h=g(e,o)&&0===this.comparePoint(o),u=g(n,s)&&0===t.comparePoint(s),c=g(e,l)&&0===this.comparePoint(l),f=g(n,r)&&0===t.comparePoint(r);if(u&&h)return f&&!c?r:!f&&c?l:null;if(u)return c&&s.x===l.x&&s.y===l.y?null:s;if(h)return f&&r.x===o.x&&r.y===o.y?null:o;if(f&&c)return null;if(f)return r;if(c)return l;const y=((t,e,n,i)=>{if(0===e.x)return I(n,i,t.x);if(0===i.x)return I(t,e,n.x);if(0===e.y)return R(n,i,t.y);if(0===i.y)return R(t,e,n.y);const s=E(e,i);if(0==s)return null;const r={x:n.x-t.x,y:n.y-t.y},o=E(r,e)/s,l=E(r,i)/s;return{x:(t.x+l*e.x+(n.x+o*i.x))/2,y:(t.y+l*e.y+(n.y+o*i.y))/2}})(s,this.vector(),o,t.vector());return null===y?null:g(i,y)?b.round(y.x,y.y):null}split(t){const e=[],n=void 0!==t.events,i=new _(t,!0),s=new _(t,!1),r=this.rightSE;this.replaceRightSE(s),e.push(s),e.push(i);const o=new k(i,r,this.rings.slice(),this.windings.slice());return _.comparePoints(o.leftSE.point,o.rightSE.point)>0&&o.swapEvents(),_.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(i.checkForConsuming(),s.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const i=k.compare(e,n);if(0!==i){if(i>0){const t=e;e=n,n=t}if(e.prev===n){const t=e;e=n,n=t}for(let t=0,i=n.rings.length;t<i;t++){const i=n.rings[t],s=n.windings[t],r=e.rings.indexOf(i);-1===r?(e.rings.push(i),e.windings.push(s)):e.windings[r]+=s}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return void 0!==this._prevInResult||(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null),this._prevInResult}beforeState(){if(void 0!==this._beforeState)return this._beforeState;if(this.prev){const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}else this._beforeState={rings:[],windings:[],multiPolys:[]};return this._beforeState}afterState(){if(void 0!==this._afterState)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,i=this._afterState.multiPolys;for(let o=0,l=this.rings.length;o<l;o++){const t=this.rings[o],i=this.windings[o],s=e.indexOf(t);-1===s?(e.push(t),n.push(i)):n[s]+=i}const s=[],r=[];for(let o=0,l=e.length;o<l;o++){if(0===n[o])continue;const t=e[o],i=t.poly;if(-1===r.indexOf(i))if(t.isExterior)s.push(i);else{-1===r.indexOf(i)&&r.push(i);const e=s.indexOf(t.poly);-1!==e&&s.splice(e,1)}}for(let o=0,l=s.length;o<l;o++){const t=s[o].multiPoly;-1===i.indexOf(t)&&i.push(t)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(q.type){case"union":{const n=0===t.length,i=0===e.length;this._isInResult=n!==i;break}case"intersection":{let n,i;t.length<e.length?(n=t.length,i=e.length):(n=e.length,i=t.length),this._isInResult=i===q.numMultiPolys&&n<i;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2==1;break}case"difference":{const n=t=>1===t.length&&t[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${q.type}`)}return this._isInResult}}class A{constructor(t,e,n){if(!Array.isArray(t)||0===t.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],"number"!=typeof t[0][0]||"number"!=typeof t[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const i=b.round(t[0][0],t[0][1]);this.bbox={ll:{x:i.x,y:i.y},ur:{x:i.x,y:i.y}};let s=i;for(let r=1,o=t.length;r<o;r++){if("number"!=typeof t[r][0]||"number"!=typeof t[r][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let e=b.round(t[r][0],t[r][1]);e.x===s.x&&e.y===s.y||(this.segments.push(k.fromRing(s,e,this)),e.x<this.bbox.ll.x&&(this.bbox.ll.x=e.x),e.y<this.bbox.ll.y&&(this.bbox.ll.y=e.y),e.x>this.bbox.ur.x&&(this.bbox.ur.x=e.x),e.y>this.bbox.ur.y&&(this.bbox.ur.y=e.y),s=e)}i.x===s.x&&i.y===s.y||this.segments.push(k.fromRing(s,i,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const n=this.segments[e];t.push(n.leftSE),t.push(n.rightSE)}return t}}class O{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new A(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,i=t.length;n<i;n++){const e=new A(t[n],this,!1);e.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=e.bbox.ll.x),e.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=e.bbox.ll.y),e.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=e.bbox.ur.x),e.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=e.bbox.ur.y),this.interiorRings.push(e)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getSweepEvents();for(let e=0,i=n.length;e<i;e++)t.push(n[e])}return t}}class L{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof t[0][0][0]&&(t=[t])}catch(n){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let i=0,s=t.length;i<s;i++){const e=new O(t[i],this);e.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=e.bbox.ll.x),e.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=e.bbox.ll.y),e.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=e.bbox.ur.x),e.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=e.bbox.ur.y),this.polys.push(e)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getSweepEvents();for(let e=0,i=n.length;e<i;e++)t.push(n[e])}return t}}class N{static factory(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];if(!i.isInResult()||i.ringOut)continue;let s=null,r=i.leftSE,o=i.rightSE;const l=[r],h=r.point,u=[];for(;s=r,r=o,l.push(r),r.point!==h;)for(;;){const t=r.getAvailableLinkedEvents();if(0===t.length){const t=l[0].point,e=l[l.length-1].point;throw new Error(`Unable to complete output ring starting at [${t.x}, ${t.y}]. Last matching segment found ends at [${e.x}, ${e.y}].`)}if(1===t.length){o=t[0].otherSE;break}let n=null;for(let e=0,s=u.length;e<s;e++)if(u[e].point===r.point){n=e;break}if(null!==n){const t=u.splice(n)[0],i=l.splice(t.index);i.unshift(i[0].otherSE),e.push(new N(i.reverse()));continue}u.push({index:l.length,point:r.point});const i=r.getLeftmostComparator(s);o=t.sort(i)[0].otherSE;break}e.push(new N(l))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let h=1,u=this.events.length-1;h<u;h++){const n=this.events[h].point,i=this.events[h+1].point;0!==S(n,t,i)&&(e.push(n),t=n)}if(1===e.length)return null;const n=e[0],i=e[1];0===S(n,t,i)&&e.shift(),e.push(e[0]);const s=this.isExteriorRing()?1:-1,r=this.isExteriorRing()?0:e.length-1,o=this.isExteriorRing()?e.length:-1,l=[];for(let h=r;h!=o;h+=s)l.push([e[h].x,e[h].y]);return l}isExteriorRing(){if(void 0===this._isExteriorRing){const t=this.enclosingRing();this._isExteriorRing=!t||!t.isExteriorRing()}return this._isExteriorRing}enclosingRing(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let i=1,s=this.events.length;i<s;i++){const e=this.events[i];_.compare(t,e)>0&&(t=e)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class ${constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(null===t[0])return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getGeom();null!==n&&t.push(n)}return t}}class M{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getGeom();null!==n&&t.push(n)}return t}_composePolys(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];if(!i.poly)if(i.isExteriorRing())e.push(new $(i));else{const t=i.enclosingRing();t.poly||e.push(new $(t)),t.poly.addInterior(i)}}return e}}class B{constructor(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:k.compare;this.queue=e,this.tree=new t(n),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const i=t.isLeft?this.tree.add(e):this.tree.find(e);if(!i)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let s,r,o=i,l=i;for(;void 0===s;)o=this.tree.prev(o),null===o?s=null:void 0===o.key.consumedBy&&(s=o.key);for(;void 0===r;)l=this.tree.next(l),null===l?r=null:void 0===l.key.consumedBy&&(r=l.key);if(t.isLeft){let i=null;if(s){const t=s.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(i=t),!s.isAnEndpoint(t))){const e=this._splitSafely(s,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}let o=null;if(r){const t=r.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(o=t),!r.isAnEndpoint(t))){const e=this._splitSafely(r,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}if(null!==i||null!==o){let t=null;if(null===i)t=o;else if(null===o)t=i;else{t=_.comparePoints(i,o)<=0?i:o}this.queue.remove(e.rightSE),n.push(e.rightSE);const s=e.split(t);for(let e=0,i=s.length;e<i;e++)n.push(s[e])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=s)}else{if(s&&r){const t=s.getIntersection(r);if(null!==t){if(!s.isAnEndpoint(t)){const e=this._splitSafely(s,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}if(!r.isAnEndpoint(t)){const e=this._splitSafely(r,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const i=t.split(e);return i.push(n),void 0===t.consumedBy&&this.tree.add(t),i}}const G="undefined"!=typeof process&&c.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,T="undefined"!=typeof process&&c.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;const q=new class{run(e,n,i){q.type=e,b.reset();const s=[new L(n,!0)];for(let t=0,c=i.length;t<c;t++)s.push(new L(i[t],!1));if(q.numMultiPolys=s.length,"difference"===q.type){const t=s[0];let e=1;for(;e<s.length;)null!==p(s[e].bbox,t.bbox)?e++:s.splice(e,1)}if("intersection"===q.type)for(let t=0,c=s.length;t<c;t++){const e=s[t];for(let n=t+1,i=s.length;n<i;n++)if(null===p(e.bbox,s[n].bbox))return[]}const r=new t(_.compare);for(let t=0,c=s.length;t<c;t++){const e=s[t].getSweepEvents();for(let t=0,n=e.length;t<n;t++)if(r.insert(e[t]),r.size>G)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const o=new B(r);let l=r.size,h=r.pop();for(;h;){const t=h.key;if(r.size===l){const e=t.segment;throw new Error(`Unable to pop() ${t.isLeft?"left":"right"} SweepEvent [${t.point.x}, ${t.point.y}] from segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] from queue.`)}if(r.size>G)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(o.segments.length>T)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const e=o.process(t);for(let n=0,i=e.length;n<i;n++){const t=e[n];void 0===t.consumedBy&&r.insert(t)}l=r.size,h=r.pop()}b.reset();const u=N.factory(o.segments);return new M(u).getGeom()}};var F={union:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return q.run("union",t,n)},intersection:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return q.run("intersection",t,n)},xor:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return q.run("xor",t,n)},difference:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return q.run("difference",t,n)}};export{F as i};
